参考资料：https://www.cnblogs.com/jiasm/p/7683930.html【浅谈script标签中的async和defer】
script 标签用于加载脚本与执行脚本
直接使用 script 脚本的话，html 会按照顺序来加载并执行脚本，在脚本加载&执行的过程中，会阻塞后续的 DOM 渲染。
现在大家习惯于在页面中引用各种的第三方脚本，如果第三方服务商出现了一些小问题，比如延迟之类的，就会使得页面白屏。
好在 script 提供了两种方式来解决上述问题，async 和 defer，这两个属性使得 script 都不会阻塞 DOM 的渲染。

defer 属性分析：

1. 如果 script 标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续 DOM 的渲染；
2. 如果有多个设置了 defer 的 script 标签存在，则会按照顺序执行所有的 script；
   即使 script2.js 加载用时比 script1.js 短，它也必须等到 script1.js 执行完毕之后在执行
3. defer 脚本会在文档渲染完毕后，DOMContentLoaded 事件调用前执行，所以 defer 脚本可以获取后面的 DOM 元素
4. inline-script 不支持 defer，但 type="module"情况下，不管是文件还是行内脚本，都会具有 defer 的特性。

async 属性分析：

1. async 的设置，会使得 script 脚本异步的加载并在允许的情况下执行
2. async 的执行，并不会按着 script 在页面中的顺序来执行，而是谁先加载完谁执行。
3. 如果 async 脚本加载的足够快，是否会在 DOMContentLoaded 之前就执行（这个实验是基于对 async 的描述“在允许的情况下执行”的论证）。
   同时为了保证测试的稳定性，我们在 script 脚本引入的后边添加了数千个空的 div 节点，用来延长文档的渲染时间。
   执行结果不出所料，如果给 async 一定的时间，是有可能在 DOMContentLoaded 事件之前就执行的。
   所以 async 脚本可能在获取后面的 DOM 元素的时候出问题

普通 script:
文档解析的过程中，如果遇到 script 脚本，就会停止页面的解析进行下载
（但是 Chrome 会做一个优化，如果遇到 script 脚本，会快速的查看后边有没有需要下载其他资源的，如果有的话，会先下载那些资源，然后再进行下载 script 所对应的资源，这样能够节省一部分下载的时间）。
资源的下载是在解析过程中进行的，虽说 script1 脚本会很快的加载完毕，但是他前边的 script2 并没有加载&执行，所以他只能处于一个挂起的状态，等待 script2 执行完毕后再执行。
当这两个脚本都执行完毕后，才会继续解析页面。
所以会看到 script 引入前的标签先渲染在浏览器上，而等到脚本执行完毕之后，后面的标签才渲染到浏览器上，这就是前面说的如果第三方服务商出现了一些小问题，比如延迟之类的，就会使得页面白屏。
这还会产生一个问题，script 后面的 DOM 元素无法在 script 文件中使用，它们还没被渲染

需要注意的是：

1. js 文件的执行一定是同步的，一个没有执行完，另一个不会开始执行
2. js 文件执行的时候，浏览器不会进行渲染操作
3. js 文件的下载和执行是 2 回事，js 文件的执行会受到标签前面样式文件的影响。如果在标签前面有样式文件，需要样式文件加载并解析完毕后才执行脚本。这是因为 javascript 可以查询对象的样式。

扩展：DOMContentLoaded 和 load 的区别，看 DOMContentLoaded 和 load 的区别.md
