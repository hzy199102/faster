var graph_dict = {
  "0": { "5": 2, "4": 3 }, // 表示从0可以到5,权值为2, 0可以到4,权值为3
  "1": { "2": 7, "3": 7, "4": 2, "5": 2 },
  "2": { "8": 8, "6": 7, "1": 7 },
  "3": { "6": 2, "10": 3, "7": 1, "1": 7 },
  "4": { "1": 2, "7": 3, "0": 3 },
  "5": { "14": 10, "1": 2, "0": 2 },
  "6": { "9": 1, "12": 4, "3": 2, "2": 7 },
  "7": { "3": 1, "11": 2, "4": 3 },
  "8": { "9": 4, "2": 8, "14": 1 },
  "9": { "13": 9, "6": 1, "8": 4 },
  "10": { "12": 6, "11": 8, "3": 3 },
  "11": { "10": 8, "7": 2 },
  "12": { "13": 2, "10": 6, "6": 4 },
  "13": { "12": 2, "9": 9 }
};

var INF = 9999;
/**
 * 最短路径问题
 *
 * 迪杰斯特拉：算法按路径长度的递增次序，逐步产生最短的路径，它可以算出始点到其他各点的最短距离
 * 1.假设从A到B存在一条最短路径AB，而C恰好在这条路径上，那么AB的子路径AC一定是从A到C的最短路径
 * 2.从顶点1出发，可以到达顶点 2，3, 4, 5 ，路径长度分别为 7， 7， 2， 2 ,
 *  这其中，到达顶点4和顶点5的长度是2，是所有能够到达顶点的最短路径，那么我们可以确定，顶点1到达顶点4的最短路径长度是2，到达顶点5的最短路径长度是2，
 *  至于到达顶点3和顶点2的路径长度是否为最短，则目前还无法确认。
 *  原理是顶点1到达顶点4的路径长度已经是从顶点1出发的边的权重中最小的了，走其他任何路线，其路径长度都大于2。
 *
 * @param {*} graph
 * @param {*} start
 * @param {*} end
 */
function dijkstra(graph, start, end) {
  var v_arr = {}; // 记录已经考察过的点，这个点周围能到达的点全部处理过，所以之后不会在处理它
  var dis = {}; // 记录从start到各个点的最小距离，这个距离可以随时被更新，不是一次判断出来的
  var path = {}; // 记录从start到具体某个顶点v的最短路径中，v的前一个顶点，从这个path可以逆向推导出start到end的最短全路径

  for (var key in graph) {
    dis[key] = INF;
  }
  var min_v = start; // 起始点是start
  dis[min_v] = 0; // 先初始化start点的最短路径，自然是0
  path[min_v] = min_v; // 初始化，自己到自己

  // 当全部的点都被判断之后，就可以跳出循环
  // 1.判断graph有N个点，每次v_arr放入一个点之后，count + 1，如果count == N，证明全部的点都被考察过，循环就结束，会有冗余，比如最后一个顶点，其实不需要处理，不过这针对的是无向连通图的情况
  // 2.判断是否还有dis[key]（key指的是顶点）的值不存在，这个有点麻烦，最好还是开始的时候就初始化全部dis[key]是最大值INF，否则等下判断dis的时候还得先判断dis是否存在在比较达大小，麻烦一点
  //   另外在计算最短路径的时候也会麻烦一点
  while (true) {
    // 证明min_v这个顶点要被处理了，之后不用管了
    v_arr[min_v] = 1;
    // 找到min_v能到达的全部顶点;
    var v_link = graph[min_v];
    for (var key in v_link) {
      // 如果不去初始化dis，想象一下这里的判断得有多麻烦啊
      // 这里是判断start到key的最短路径 和 start到min_v的最短路径 + min_v到key的路径 的大小，据此更新最短路径
      // 从这里可以得到个隐藏的结论，必须以确定的最短路径为基础去做接下来的最短路径判断
      if (dis[min_v] + v_link[key] < dis[key]) {
        dis[key] = dis[min_v] + v_link[key]; // 重新确认从start到key的最短路径
        path[key] = min_v; // 从start出发到达key的最短路径中,一定要通过min_v到达key
      }
    }

    // 从剩下的没有处理的顶点中选取具有最短路径的顶点（看前面的隐藏结论，思考如果不这样做会有什么后果？）
    var min_dis = INF;
    for (var key in graph) {
      // 先排除已经处理的顶点
      if (v_arr[key]) {
        continue;
      }
      // 选取具有最短路径的顶点
      if (dis[key] < min_dis) {
        min_v = key;
        min_dis = dis[key];
      }
    }
    // 如果全部的点都被处理完，跳出循环
    if (min_dis === INF) {
      break;
    }
  }

  // 输出最短路径
  var link_path = [];
  var tmp_v = path[end];
  link_path.push(end);
  while (tmp_v) {
    link_path.push(tmp_v);
    tmp_v = path[tmp_v];
    if (tmp_v === start) {
      link_path.push(start);
      break;
    }
  }

  console.log(link_path);
  console.log(path);
}

dijkstra(graph_dict, "1", "13");
